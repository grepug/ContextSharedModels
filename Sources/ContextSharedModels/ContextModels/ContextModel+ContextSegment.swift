//
//  ContextModel+ContextSegment.swift
//
//
//  Created by Kai Shao on 2024/6/16.
//

import Foundation

extension ContextModel {
    public struct ContextSegment: ContextModelKind, TokenKind {
        public static var typeName: String {
            "ContextSegment"
        }

        public var id: ID
        public var createdAt: Date
        public var contextID: ID?
        public var collectionID: ID?
        public var segment: Segment
        public var text: String
        /// Lemma of the text, if the text is a word.
        ///
        /// A segment can necessarily not have a lemma, because it isn't a word.
        public var lemma: String?
        public var pos: PartOfSpeech?
        public var synonym: String?
        public var tag: ContextModel.TokenTag?
        /// Sense generated by LLM.
        ///
        /// Exists if there isn't a sense in the dictionary.
        public var sense: LocaledStringDict?
        /// Descriptons generated by LLM that is used to describe the segment with the context.
        public var desc: LocaledStringDict
        /// Sense ID of the entry sense that this segment belongs to.
        ///
        /// This is used to link the segment to the entry sense.
        public var entrySense: EntrySense?

        public var dictionaryName: String?
        /// Entry ID of the entry that this segment belongs to.
        ///
        /// This is used to link the segment to the entry.
        public var entryID: ID?

        public var temporary: Bool

        // if the lemma is nil, then use the text as the lemma
        public var normalizedLemma: String {
            lemma ?? text
        }

        public var range: [Int] {
            get {
                switch segment {
                case .textRange(let segmentTextRange):
                    return [segmentTextRange.lowerBound, segmentTextRange.upperBound]
                }

            }
            set {
                guard newValue.count == 2 else {
                    return
                }

                let lowerBound = newValue[0]
                let upperBound = newValue[1]

                switch segment {
                case .textRange(var segmentTextRange):
                    segmentTextRange = CharacterRange(lowerBound: lowerBound, upperBound: upperBound)
                    segment = .textRange(segmentTextRange)
                }
            }
        }

        // optional has context item
        public var context: ContextModel.Context?

        public var textRange: CharacterRange? {
            switch segment {
            case .textRange(let segmentTextRange):
                return segmentTextRange
            }
        }

        public func subtextRange(from string: String) -> Range<String.Index>? {
            switch segment {
            case .textRange(let range):
                // Guard to ensure the range is within bounds
                guard range.lowerBound >= 0, range.upperBound <= string.count, range.lowerBound < range.upperBound else {
                    return nil
                }

                let start = string.index(string.startIndex, offsetBy: range.lowerBound)
                let end = string.index(string.startIndex, offsetBy: range.upperBound)
                return start..<end
            }
        }

        public func subtextRange(from aString: AttributedString) -> Range<AttributedString.Index>? {
            let string = NSAttributedString(aString).string

            switch segment {
            case .textRange(let range):
                // Guard to ensure the range is within bounds
                guard range.lowerBound >= 0, range.upperBound <= string.count, range.lowerBound < range.upperBound else {
                    return nil
                }

                let start = aString.index(aString.startIndex, offsetByCharacters: range.lowerBound)
                let end = aString.index(aString.startIndex, offsetByCharacters: range.upperBound)

                return start..<end
            }
        }

        public init(
            id: ID = Foundation.UUID().uuidString, createdAt: Date = .now, contextID: ID? = nil, segment: Segment = .textRange(.placeholder), text: String = "",
            lemma: String? = nil, pos: PartOfSpeech? = nil, synonym: String? = nil, sense: LocaledStringDict = [:], desc: LocaledStringDict = [:], phoneticSymbols: PhoniticSymbolDict = [:],
            context: Context? = nil, temporary: Bool = false
        ) {
            self.id = id
            self.createdAt = createdAt
            self.contextID = contextID
            self.segment = segment
            self.temporary = temporary
            self.text = text
            self.lemma = lemma
            self.pos = pos
            self.synonym = synonym
            self.sense = sense
            self.desc = desc
            self.context = context
        }

        public init?(
            id: ID, createdAt: Date = .now, contextID: ID? = nil, segmentString: String?, text: String = "", lemma: String? = nil, pos: PartOfSpeech? = nil,
            synonym: String? = nil,
            sense: LocaledStringDict = [:], desc: LocaledStringDict = [:], context: Context? = nil, temporary: Bool = false
        ) {
            guard let segmentString,
                let textSegment = CharacterRange(string: segmentString)
            else {
                return nil
            }

            self.id = id
            self.createdAt = createdAt
            self.contextID = contextID
            self.temporary = temporary
            self.segment = .textRange(textSegment)
            self.text = text
            self.lemma = lemma
            self.pos = pos
            self.synonym = synonym
            self.sense = sense
            self.desc = desc
            self.context = context
        }

        public init() {
            self.init(id: UUID().uuidString)
        }
    }
}

extension ContextModel.ContextSegment {
    public enum Segment: Hashable, CoSendable {
        case textRange(CharacterRange)

        public var textRange: CharacterRange? {
            if case .textRange(let range) = self {
                return range
            }

            return nil
        }
    }
}
